"""
Phaser CI Integration

Generates CI workflow files for automated contract checking.
Supports GitHub Actions with extensibility for other platforms.
"""

from __future__ import annotations

from dataclasses import dataclass, field
from datetime import datetime, timezone
from enum import Enum
from pathlib import Path
from typing import TYPE_CHECKING, Any

import click
import yaml

if TYPE_CHECKING:
    from tools.storage import PhaserStorage


# =============================================================================
# Enums
# =============================================================================


class CIPlatform(str, Enum):
    """Supported CI platforms."""

    GITHUB = "github"
    GITLAB = "gitlab"
    CIRCLECI = "circleci"


# =============================================================================
# Data Classes
# =============================================================================


@dataclass
class CIConfig:
    """Configuration for CI workflow generation."""

    platform: CIPlatform
    workflow_path: Path
    generated_at: str
    phaser_version: str
    python_version: str = "3.11"
    on_push: bool = True
    on_pr: bool = True
    branches: list[str] = field(default_factory=lambda: ["main", "master"])
    fail_on_warning: bool = False

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            "version": 1,
            "platform": self.platform.value,
            "workflow_path": str(self.workflow_path),
            "generated_at": self.generated_at,
            "phaser_version": self.phaser_version,
            "options": {
                "python_version": self.python_version,
                "on_push": self.on_push,
                "on_pr": self.on_pr,
                "branches": self.branches,
                "fail_on_warning": self.fail_on_warning,
            },
        }

    @classmethod
    def from_dict(cls, d: dict[str, Any]) -> CIConfig:
        """Create from dictionary."""
        options = d.get("options", {})
        return cls(
            platform=CIPlatform(d["platform"]),
            workflow_path=Path(d["workflow_path"]),
            generated_at=d["generated_at"],
            phaser_version=d["phaser_version"],
            python_version=options.get("python_version", "3.11"),
            on_push=options.get("on_push", True),
            on_pr=options.get("on_pr", True),
            branches=options.get("branches", ["main", "master"]),
            fail_on_warning=options.get("fail_on_warning", False),
        )


@dataclass
class CIStatus:
    """Status of CI integration for a project."""

    platform: CIPlatform
    workflow_exists: bool
    workflow_path: Path | None
    config: CIConfig | None
    contract_count: int
    error_count: int
    warning_count: int

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            "platform": self.platform.value,
            "workflow_exists": self.workflow_exists,
            "workflow_path": str(self.workflow_path) if self.workflow_path else None,
            "config": self.config.to_dict() if self.config else None,
            "contract_count": self.contract_count,
            "error_count": self.error_count,
            "warning_count": self.warning_count,
        }


# =============================================================================
# Constants
# =============================================================================


PHASER_VERSION = "1.3.0"

DEFAULT_WORKFLOW_PATHS: dict[CIPlatform, str] = {
    CIPlatform.GITHUB: ".github/workflows/phaser.yml",
    CIPlatform.GITLAB: ".gitlab-ci.yml",
    CIPlatform.CIRCLECI: ".circleci/config.yml",
}

SUPPORTED_PYTHON_VERSIONS = ["3.10", "3.11", "3.12", "3.13"]


# =============================================================================
# Workflow Templates
# =============================================================================


GITHUB_WORKFLOW_TEMPLATE = """\
# Generated by Phaser v{phaser_version}
# https://github.com/anthropics/phaser
# Generated at: {generated_at}

name: Phaser Contract Check

on:
{triggers}

jobs:
  phaser-check:
    name: Check Contracts
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "{python_version}"

      - name: Install Phaser
        run: |
          pip install phaser

      - name: Run contract checks
        run: |
          phaser check --fail-on-error{fail_on_warning_flag} --format text

      - name: Save results
        if: always()
        run: |
          mkdir -p .phaser
          phaser check --format json > .phaser/check-results.json || true

      - name: Upload results (on failure)
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: phaser-results
          path: .phaser/check-results.json
          retention-days: 7
"""


def _format_branches_yaml(branches: list[str], indent: int = 6) -> str:
    """Format branch list as YAML array."""
    if not branches:
        return "[]"
    lines = [f"{' ' * indent}- {branch}" for branch in branches]
    return "\n".join(lines)


def _generate_triggers(
    on_push: bool,
    on_pr: bool,
    branches: list[str],
) -> str:
    """Generate the 'on:' section for GitHub Actions."""
    triggers = []
    branch_yaml = _format_branches_yaml(branches, indent=6)

    if on_push:
        triggers.append(f"  push:\n    branches:\n{branch_yaml}")

    if on_pr:
        triggers.append(f"  pull_request:\n    branches:\n{branch_yaml}")

    if not triggers:
        # At least one trigger required
        triggers.append("  workflow_dispatch:")

    return "\n".join(triggers)


def generate_workflow(platform: CIPlatform, config: CIConfig) -> str:
    """
    Generate workflow file content for the specified platform.

    Args:
        platform: Target CI platform
        config: Workflow configuration

    Returns:
        Workflow file content as string

    Raises:
        ValueError: If platform is not supported
    """
    if platform == CIPlatform.GITHUB:
        triggers = _generate_triggers(config.on_push, config.on_pr, config.branches)
        fail_flag = " --fail-on-warning" if config.fail_on_warning else ""

        return GITHUB_WORKFLOW_TEMPLATE.format(
            phaser_version=config.phaser_version,
            generated_at=config.generated_at,
            triggers=triggers,
            python_version=config.python_version,
            fail_on_warning_flag=fail_flag,
        )

    elif platform == CIPlatform.GITLAB:
        raise ValueError(
            f"Platform '{platform.value}' is planned but not yet supported. "
            "Currently supported: github"
        )

    elif platform == CIPlatform.CIRCLECI:
        raise ValueError(
            f"Platform '{platform.value}' is planned but not yet supported. "
            "Currently supported: github"
        )

    else:
        raise ValueError(
            f"Unknown platform: {platform}. "
            f"Supported platforms: {', '.join(p.value for p in CIPlatform)}"
        )


# =============================================================================
# Core Functions
# =============================================================================


def init_ci(
    storage: PhaserStorage,
    root: Path,
    platform: CIPlatform = CIPlatform.GITHUB,
    python_version: str = "3.11",
    on_push: bool = True,
    on_pr: bool = True,
    branches: list[str] | None = None,
    fail_on_warning: bool = False,
    output_path: Path | None = None,
    force: bool = False,
) -> tuple[Path, CIConfig]:
    """
    Initialize CI integration for the project.

    Args:
        storage: PhaserStorage instance
        root: Project root directory
        platform: Target CI platform
        python_version: Python version for workflow
        on_push: Trigger on push events
        on_pr: Trigger on pull request events
        branches: Branches to trigger on (default: main, master)
        fail_on_warning: Fail on warning-severity violations
        output_path: Custom workflow output path
        force: Overwrite existing workflow

    Returns:
        Tuple of (workflow_path, config)

    Raises:
        FileExistsError: If workflow exists and force=False
        ValueError: If configuration is invalid
    """
    # Validate Python version
    if python_version not in SUPPORTED_PYTHON_VERSIONS:
        raise ValueError(
            f"Invalid Python version: {python_version}. "
            f"Supported versions: {', '.join(SUPPORTED_PYTHON_VERSIONS)}"
        )

    # Determine workflow path
    if output_path:
        workflow_path = root / output_path
    else:
        workflow_path = root / DEFAULT_WORKFLOW_PATHS[platform]

    # Check if workflow exists
    if workflow_path.exists() and not force:
        raise FileExistsError(
            f"Workflow file already exists: {workflow_path}\n"
            "Use --force to overwrite."
        )

    # Set defaults
    if branches is None:
        branches = ["main", "master"]

    # Create config
    now = datetime.now(timezone.utc).isoformat(timespec="seconds")
    config = CIConfig(
        platform=platform,
        workflow_path=workflow_path,
        generated_at=now,
        phaser_version=PHASER_VERSION,
        python_version=python_version,
        on_push=on_push,
        on_pr=on_pr,
        branches=branches,
        fail_on_warning=fail_on_warning,
    )

    # Generate workflow content
    content = generate_workflow(platform, config)

    # Create directories and write workflow
    workflow_path.parent.mkdir(parents=True, exist_ok=True)
    workflow_path.write_text(content, encoding="utf-8")

    # Save config to .phaser/ci.yaml
    storage.ensure_directories()
    ci_config_path = storage.get_path("ci.yaml")
    with open(ci_config_path, "w", encoding="utf-8") as f:
        yaml.dump(config.to_dict(), f, default_flow_style=False, sort_keys=False)

    return workflow_path, config


def get_ci_status(storage: PhaserStorage, root: Path) -> CIStatus:
    """
    Get CI integration status for the project.

    Args:
        storage: PhaserStorage instance
        root: Project root directory

    Returns:
        CIStatus with current state
    """
    from tools.contracts import Severity, load_contracts

    # Load config if exists
    ci_config_path = storage.get_path("ci.yaml")
    config: CIConfig | None = None
    platform = CIPlatform.GITHUB  # Default

    if ci_config_path.exists():
        with open(ci_config_path, encoding="utf-8") as f:
            config_dict = yaml.safe_load(f)
            if config_dict:
                config = CIConfig.from_dict(config_dict)
                platform = config.platform

    # Check workflow existence
    if config:
        workflow_path = config.workflow_path
        if not workflow_path.is_absolute():
            workflow_path = root / workflow_path
    else:
        workflow_path = root / DEFAULT_WORKFLOW_PATHS[platform]

    workflow_exists = workflow_path.exists()

    # Count contracts
    try:
        contracts = load_contracts(storage, enabled_only=True)
        contract_count = len(contracts)
        error_count = sum(1 for c in contracts if c.rule.severity == Severity.ERROR)
        warning_count = sum(1 for c in contracts if c.rule.severity == Severity.WARNING)
    except Exception:
        contract_count = 0
        error_count = 0
        warning_count = 0

    return CIStatus(
        platform=platform,
        workflow_exists=workflow_exists,
        workflow_path=workflow_path if workflow_exists else None,
        config=config,
        contract_count=contract_count,
        error_count=error_count,
        warning_count=warning_count,
    )


def remove_ci(
    storage: PhaserStorage,
    root: Path,
    platform: CIPlatform = CIPlatform.GITHUB,
) -> bool:
    """
    Remove CI workflow file.

    Args:
        storage: PhaserStorage instance
        root: Project root directory
        platform: Target CI platform

    Returns:
        True if removed, False if not found
    """
    # Get current config or default path
    ci_config_path = storage.get_path("ci.yaml")

    if ci_config_path.exists():
        with open(ci_config_path, encoding="utf-8") as f:
            config_dict = yaml.safe_load(f)
            if config_dict:
                config = CIConfig.from_dict(config_dict)
                workflow_path = config.workflow_path
                if not workflow_path.is_absolute():
                    workflow_path = root / workflow_path
            else:
                workflow_path = root / DEFAULT_WORKFLOW_PATHS[platform]
    else:
        workflow_path = root / DEFAULT_WORKFLOW_PATHS[platform]

    # Remove workflow file
    removed = False
    if workflow_path.exists():
        workflow_path.unlink()
        removed = True

    # Remove config file
    if ci_config_path.exists():
        ci_config_path.unlink()

    return removed


def format_ci_status(status: CIStatus) -> str:
    """
    Format CI status for terminal display.

    Args:
        status: CIStatus to format

    Returns:
        Formatted string for display
    """
    lines = [
        "CI Integration Status",
        "=====================",
        f"Platform: {status.platform.value.title()} Actions",
    ]

    if status.workflow_exists and status.workflow_path:
        lines.append(f"Workflow: {status.workflow_path}")
        lines.append("Status: Active")
    else:
        lines.append(f"Workflow: {DEFAULT_WORKFLOW_PATHS[status.platform]}")
        lines.append("Status: Not configured")

    if status.config:
        lines.append(f"Last generated: {status.config.generated_at}")
        lines.append("")
        lines.append("Triggers:")
        if status.config.on_push:
            branches = ", ".join(status.config.branches)
            lines.append(f"  - push to: {branches}")
        if status.config.on_pr:
            branches = ", ".join(status.config.branches)
            lines.append(f"  - pull_request to: {branches}")
        if not status.config.on_push and not status.config.on_pr:
            lines.append("  - workflow_dispatch (manual)")

    lines.append("")
    lines.append(f"Contracts: {status.contract_count} enabled")
    if status.contract_count > 0:
        lines.append(f"  - {status.error_count} error-severity")
        lines.append(f"  - {status.warning_count} warning-severity")

    return "\n".join(lines)


# =============================================================================
# CLI Interface
# =============================================================================


@click.group()
def cli() -> None:
    """CI integration commands."""
    pass


@cli.command()
@click.option(
    "--platform",
    type=click.Choice([p.value for p in CIPlatform]),
    default="github",
    help="CI platform (default: github)",
)
@click.option(
    "--output",
    type=click.Path(),
    default=None,
    help="Custom output path for workflow file",
)
@click.option(
    "--python-version",
    default="3.11",
    help="Python version for workflow (default: 3.11)",
)
@click.option("--on-push/--no-on-push", default=True, help="Trigger on push events")
@click.option("--on-pr/--no-on-pr", default=True, help="Trigger on pull request events")
@click.option(
    "--branches",
    default="main,master",
    help="Branches to trigger on, comma-separated (default: main,master)",
)
@click.option(
    "--fail-on-warning",
    is_flag=True,
    help="Also fail on warning-severity violations",
)
@click.option("--force", is_flag=True, help="Overwrite existing workflow file")
@click.option("--dry-run", is_flag=True, help="Print workflow without writing file")
def init(
    platform: str,
    output: str | None,
    python_version: str,
    on_push: bool,
    on_pr: bool,
    branches: str,
    fail_on_warning: bool,
    force: bool,
    dry_run: bool,
) -> None:
    """
    Generate CI workflow file for contract checking.

    Creates a workflow file that runs 'phaser check' on every
    push and/or pull request to specified branches.

    Examples:

        phaser ci init

        phaser ci init --python-version 3.12

        phaser ci init --dry-run

        phaser ci init --no-on-push --branches main
    """
    from tools.storage import PhaserStorage

    storage = PhaserStorage()
    root = Path.cwd()

    # Parse branches
    branch_list = [b.strip() for b in branches.split(",") if b.strip()]

    # Create config for preview/generation
    now = datetime.now(timezone.utc).isoformat(timespec="seconds")
    config = CIConfig(
        platform=CIPlatform(platform),
        workflow_path=Path(output) if output else Path(DEFAULT_WORKFLOW_PATHS[CIPlatform(platform)]),
        generated_at=now,
        phaser_version=PHASER_VERSION,
        python_version=python_version,
        on_push=on_push,
        on_pr=on_pr,
        branches=branch_list,
        fail_on_warning=fail_on_warning,
    )

    if dry_run:
        # Just print the workflow
        content = generate_workflow(CIPlatform(platform), config)
        click.echo(content)
        return

    try:
        workflow_path, config = init_ci(
            storage=storage,
            root=root,
            platform=CIPlatform(platform),
            python_version=python_version,
            on_push=on_push,
            on_pr=on_pr,
            branches=branch_list,
            fail_on_warning=fail_on_warning,
            output_path=Path(output) if output else None,
            force=force,
        )
        click.echo(f"Created {workflow_path}")

        # Warn if no contracts
        ci_status = get_ci_status(storage, root)
        if ci_status.contract_count == 0:
            click.echo(
                "\nWarning: No contracts found. CI check will always pass.\n"
                "Use 'phaser contracts create' to add contracts."
            )

    except FileExistsError as e:
        click.echo(f"Error: {e}", err=True)
        raise SystemExit(1)
    except ValueError as e:
        click.echo(f"Error: {e}", err=True)
        raise SystemExit(2)


@cli.command()
@click.option(
    "--format",
    "output_format",
    type=click.Choice(["text", "json"]),
    default="text",
    help="Output format",
)
def status(output_format: str) -> None:
    """
    Show CI integration status.

    Displays the current CI configuration, workflow file status,
    and contract counts.

    Examples:

        phaser ci status

        phaser ci status --format json
    """
    import json

    from tools.storage import PhaserStorage

    storage = PhaserStorage()
    root = Path.cwd()

    ci_status = get_ci_status(storage, root)

    if output_format == "json":
        click.echo(json.dumps(ci_status.to_dict(), indent=2))
    else:
        click.echo(format_ci_status(ci_status))

    # Exit code based on configuration status
    if not ci_status.workflow_exists:
        raise SystemExit(1)


@cli.command()
@click.option(
    "--platform",
    type=click.Choice([p.value for p in CIPlatform]),
    default="github",
    help="CI platform",
)
@click.option("--force", is_flag=True, help="Remove without confirmation")
def remove(platform: str, force: bool) -> None:
    """
    Remove CI workflow file.

    Removes the generated workflow file and CI configuration.

    Examples:

        phaser ci remove

        phaser ci remove --force
    """
    from tools.storage import PhaserStorage

    storage = PhaserStorage()
    root = Path.cwd()

    # Confirm unless --force
    if not force:
        ci_status = get_ci_status(storage, root)
        if ci_status.workflow_exists:
            click.confirm(
                f"Remove {ci_status.workflow_path}?",
                abort=True,
            )

    removed = remove_ci(storage, root, CIPlatform(platform))

    if removed:
        click.echo("CI workflow removed.")
    else:
        click.echo("No CI workflow found.")
